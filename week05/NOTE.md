# 学习笔记

# 1. CSS计算 | 收集CSS规则

要想做css computing这个过程，就需要对css进行语法和词法的分析。这个过程如果完全手工来做的话，是需要较多的编译原理基础知识的。

不过此处编译原理不是重点，就用npm上现成的一个包，css，其实它是一个css parser（解析器）。

css parser 就是把css的代码变成AST（抽象语法树）这样的一个过程，降低工作量，我们需要做的就是更具这课抽象语法树，然后来抽出各种css规则，并且把他们应用到HTML元素上。

css computing 虽然是号称是“css computing"，其实它是发生在DOM树构建的时候。

进行css计算之前，先要拿到css规则。

### 第一步总结：

- 遇到style标签时，把css规则保存起来。
- 调用现成的css parser 来分析css规则。
- 注意：必须要仔细研究该库分析css规则的样式


# 2. CSS计算 | 添加调用

css规则已收集，应该找个时机，把收集的规则给应用上去，应用的时机肯定是越早越好。

css设计里面，有一条隐藏的潜规则：css设计会尽量保证所有的选择器都能够在startTag进入的时候就能够被判断。

当然后面又加了一些高级的选择器之后，这个规则有所松动，但是大部分还是遵循这个规则。当DOM树构建到元素的startTag的步骤，就已经可以判断出来它能匹配哪些css规则了。

toy-brower重在讲原理。

### 第二步总结：

- 创建一个元素后，立即计算css。（computeCSS方法写在startTag里边）
- 分析一个元素时，假设所有css规则已收集完毕。（这样的话，所有head里边的元素我们是没有办法计算它的css的，真实浏览器还是有必要的）
- 在真实浏览器中，可能遇到写在body中的style标签，需要重新css计算的情况，这里我们忽略。

# 3. CSS计算 | 获取父元素序列

为什么要获取父元素序列？

winter：因为今天的选择器大多数是跟元素的父元素相关的。

### 第三步总结：

- 在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配。
- 我们从上一步骤的stack，可以获取本元素所有的父元素。
- 因为首先获取的是“当前元素”，所以我们获得和计算父元素匹配的顺序是由内向外。

关于“从内向外”匹配，比如： div div #myid {}

前面两个div是空格，是一个子孙选择器，不确定这两个div到底要跟哪个父元素匹配，但是最后一个#myid，它是一定会跟当前元素相匹配的，所以要想高效的实现一个css选择器的匹配规则，那么一定是先去检查最后一个myid选择器，不管是什么选择，#，或者tagName，一定要先检查它是否匹配当前元素。


# 4. CSS计算 | 选择器与元素的匹配

开始处理选择器跟元素的匹配问题。

选择器是有一个层级结构的，最外层的叫做选择器列表，css parser已经帮我们做了拆分。
选择器列表里边的叫做复杂选择器，复杂选择器由空格分割的，根据亲代关系，去选择元素。

复合选择器它是针对一个元素的本身的属性和特征的一个判断，而复合原则性选择器它又是由紧连着的一堆的简单选择器而构成的。

在toy browser中，就假设一个复杂选择器里边只包含简单选择器，就不处理复合的情况。

第四步总结：

- 选择器也要从当前元素向外排列
- 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列。（这里是两个数组同时进行的一个循环，算法算是整个选择器的匹配算法里面的一个小难点，此处需要多下一点功夫）

# 5. CSS计算 | 计算选择器与元素匹配

### 第五步总结:

- 根据选择器的类型和元素属性，计算是否与当前元素匹配
- 仅实现了三种基本选择器，实际浏览器要处理符合选择器

自己代码问题遗留：toy-brower对`<img />`这种标签处理有问题，待排查

# 6. CSS计算 | 生成computed属性

把rules规则一条条的作用到computed 的属性上面。

完成了应用规则到元素上，但没有做优先级处理。

### 第六步总结：

- 一旦匹配上了，就应用选择器到元素上，形成computedStyle

# 7. CSS计算 | specificity的计算逻辑

英文中：
priority 优先级
specificity 特征，专一性

这里介绍css规则，中文常把specificity 称为优先级。

specificity计算逻辑：根据单个的复杂选择器去加起来去计算的。

比如： div div #id，会以某种规则算出来一个specificity。

specificity 是一个四元组，左边是优先级最高的一位，依次优先级下降。

[0,      0,   0,      0]
inline   id   class   tag

inline：写在style，覆盖关系最高.

### 第七步总结：

- css规则根据specificity和后来优先规则覆盖
- specificity是个四元组，越左权重越高
- 一个css规则的specificity根据包含的简单选择器相加而成

至此，已经完成所有css computing

# 8. 排版 | 根据浏览器属性进行排版

排版，layout，也叫布局。

这一步就是通过排版的计算，得到一个带位置的dom树。

整个css里边包含三代排版技术：

- 第一代：正常流，包含了positon, display, float等一系列属性。
- 第二代：flex，比较接近人的自然思维。
- 第三代：grid，更强大。

css houdini 隐约第四代。

toy-brower，采用flex排版为例。容易实现，能力也不差。重在感受排版过程和思路。

总结：

这一小节都是一些预处理的工作，并没有开始编码算法。

这些准备工作处理了flexDirection 和 wrap 相关的属性，把具体的width height left right top bottom等属性抽象成 main cross 相关属性。

# 9. 排版 | 收集元素进行（把元素收进行里面）

### 分行

- 根据主轴尺寸，把元素分行
- 若设置了no-wrap，则强行分配进入第一行。

# 10. 排版 | 计算主轴

### 计算主轴方向

- 找出所有flex元素
- 把主轴方向的剩余尺寸按比例分配给这些元素
- 若剩余空间为负数，所有flex元素为0，等比压缩剩余元素

# 11. 排版 | 计算交叉轴

# 12. 渲染 | 绘制单个元素

需要一个图形环境。

npm install images

绘制是在一个viewport上进行。

# 13. 渲染 | 绘制DOM树

- 递归调用子元素绘制方法完成整个dom树。
- 忽略一些不需要绘制的节点
- 实际浏览器中，文字绘制是难点，需要依赖字体库，toy-brower忽略
